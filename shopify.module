<?php

/**
 * Implements hook_views_api().
 */
function shopify_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'shopify') . '/views'
  );
}

/**
 * Implements hook_views_default_views().
 *
 * Imports views from the /views directory.
 */
function shopify_views_default_views() {
  $path = __DIR__ . '/views/*.view.inc';
  $views = array();
  foreach (glob($path) as $views_filename) {
    $view = FALSE;
    require_once($views_filename);
    $views[$view->name] = $view; // $view exists in the included file.
    unset($view);
  }
  return $views;
}

function shopify_sync_products(array $options = array()) {
  //@todo add some conditions instead of completely resetting every time
  $existing = db_query('SELECT s.id FROM {shopify_products} s');
  $ids = $existing->fetchCol();
  shopify_product_delete_multiple($ids);
  $products = shopify_api_get_products();
  foreach ($products as $product) {
    $shopify_product = new ShopifyProduct($product);
    shopify_product_set_images($shopify_product, $product, 'product');
    shopify_product_set_terms($shopify_product, $product);
    foreach ($product['variants'] as $v) {
      $variant = new ShopifyProduct($v);
      $variant->save();
    }
    $shopify_product->save();
  }
}

function shopify_product_set_images(&$product_entity, $product, $type) {
  $directory = file_build_uri('shopify_images');
  if (!file_prepare_directory($directory, FILE_CREATE_DIRECTORY)) {
    // If our directory doesn't exist and can't be created, use the default.
    $directory = NULL;
  }

  // Handle the instance of the main product image.
  // @todo multiple images on a main product,
  // @todo multiple images on a variant
  if ($type == 'product' && isset($product['image']['src'])) {
    $file = system_retrieve_file($product['image']['src'], $directory, TRUE, FILE_EXISTS_REPLACE);
    $wrapper = entity_metadata_wrapper('shopify_product', $product_entity);
    $wrapper->shopify_product_images->set(array((array) $file));
    $wrapper->save(TRUE);
  }
}

function shopify_product_set_terms(&$product_entity, $product) {
  foreach (explode(',', $product['tags']) as $tag) {
    $tag = trim($tag);
    if ($tag) {
      $term = taxonomy_get_term_by_name($tag, 'shopify_tags');
      if (!empty($term)) {
        $tid = reset($term)->tid;
      }
      else {
        $vocab = taxonomy_vocabulary_machine_name_load('shopify_tags');
        $term = new stdClass();
        $term->name = $tag;
        $term->vid = $vocab->vid;
        taxonomy_term_save($term);
        $tid = $term->tid;
      }
      $terms[] = $tid;
    }
  }

  $wrapper = entity_metadata_wrapper('shopify_product', $product_entity);
  $wrapper->shopify_product_tags->set($terms);
  $wrapper->save(TRUE);
}

/**
 * Implements hook_menu().
 */
function shopify_menu() {
  $items['admin/structure/shopify_products'] = array(
    'title' => 'Shopify Products',
    'description' => 'Manage Shopify Products',
    'page callback' => 'shopify_products_fields_admin',
    'access arguments' => array('administer shopify products'),
  );

  $items['products/view/%shopify_product'] = array(
    'page callback' => 'entity_ui_entity_page_view',
    'page arguments' => array(2),
    'load arguments' => array('shopify_product'),
    'access arguments' => array(TRUE),
  );
  return $items;
}

/**
 * Page callback for the bundle admin.
 */
function shopify_products_fields_admin() {
  return t('Administer Shopify Product fields and display');
}


/**
 *  Implements hook_entity_info().
 */
function shopify_entity_info() {
  return array(
    'shopify_product' => array(
      'label' => t('Shopify Product'),
      'label callback' => 'shopify_product_label',
      'uri callback' => 'shopify_product_uri',
      'entity class' => 'ShopifyProduct',
      'controller class' => 'ShopifyProductController',
      'base table' => 'shopify_products',
      'metatags' => TRUE,
      'entity keys' => array(
        'id' => 'id',
        'label' => 'title'
      ),
      'fieldable' => TRUE,
      'metadata controller class' => 'ShopifyProductMetadataController',
      'extra fields controller class' => 'EntityDefaultExtraFieldsController',
      'admin ui' => array(
        'path' => 'admin/content/products',
        'controller class' => 'EntityDefaultUIController',
        'menu wildcard' => '%shopify_product',
      ),
      'bundles' => array(
        'shopify_product' => array(
          'label' => 'Shopify Products',
          'metatags' => TRUE,
          'admin' => array(
            'path' => 'admin/structure/shopify_products',
          ),
        ),
      ),
      'view modes' => array(
        'add_to_cart' => array(
          'label' => t('Add to cart'),
          'custom settings' => FALSE,
        ),
      ),
      'load hook' => 'shopify_product_load',
//      'static cache' => TRUE,
      'module' => 'shopify',
      'access callback' => 'shopify_product_access',
    ),
  );
}

/**
 * Add to cart form for Shopify products.
 */
function shopify_add_to_cart_form($form, &$form_state, ShopifyProduct $product = NULL) {
  $form_id = 'shopify-add-to-cart-form-' . $product->handle;
  $form['#id'] = $form_id;
  $form['#action'] = 'https://' . variable_get('shopify_api_domain') . '/cart/add';

  if ($product) {
    $form['#product'] = $product;
  }
  elseif ($form['#product']) {
    $product = $form['#product'];
  }

  if ((!isset($form_state['values']) || empty($form_state['values']['options'])) && $product->variants) {
    // Set default variant to the first one we have.
    $default_variant = reset($product->variants);
  }
  elseif ($product->variants) {
    // Set variant based on options passed.
    $default_variant = shopify_add_to_cart_get_variant_from_options($product, $form_state['values']['options']);
  }
  else {
    $default_variant = $product;
  }

  // Required POST fields for add to cart form.
  $form['id'] = array(
    '#type' => 'hidden',
    '#value' => $default_variant->variant_id,
  );
  $form['return_to'] = array(
    '#type' => 'hidden',
    '#value' => 'back',
  );

  $form['product'] = array(
//    '#type' => 'fieldset',
//    '#description' => t($product->body_html),
  );

//  if ($product->variants) {
//    $form['product']['#title'] .= $default_variant->label();
//  }

  $form['product']['variant'] = array(//    '#type' => 'fieldset',
  );

//  $form['product']['variant']['body_html'] = array(
//    '#markup' => $default_variant->wrapper()->body_html->value(),
//  );

//  $images = $product->wrapper()->shopify_product_images->value();
//  if ($images[0]) {
//    $form['product']['variant']['image'] = array(
//      '#theme' => 'image',
//      'path' => file_icon_path($images[0]['uri']),
//    );
//  }

  if ($product->variants) {
    $form['product']['variant']['options']['#tree'] = TRUE;
    // Create option select lists based on product options.
    foreach ($product->options as $key => $select_list) {
      $form['product']['variant']['options'][] = array(
        '#type' => 'select',
        '#title' => t($select_list['name']),
        '#options' => array(),
        '#default_value' => $default_variant->option_values[$key],
        '#ajax' => array(
          'wrapper' => $form_id,
          'method' => 'replace',
          'callback' => 'shopify_add_to_cart_ajax_callback',
        ),
      );
    }

    // Create option lists based on variant options that are available.
    foreach ((array) $product->variants as $v) {
      foreach ((array) $v->option_values as $key => $option_value) {
        $form['product']['variant']['options'][$key]['#options'][$option_value] = $option_value;
      }
    }
  }

  $form['product']['variant']['price'] = array(
    '#markup' => $default_variant->wrapper()->price->value(),
  );

  $form['product']['variant']['actions'] = array(
    '#type' => 'actions',
    'submit' => array(
      '#type' => 'submit',
      '#value' => t('Add to Cart'),
    ),
  );

  return $form;
}

/**
 * Load a product by it's given variant_id.
 *
 * @param int $variant_id
 *   Product variant ID.
 * @return ShopifyProduct[]
 *   Returns an array of shopify products with the variant id.
 */
function shopify_product_load_by_variant_id($variant_id) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'shopify_product')
    ->propertyCondition('variant_id', $variant_id)
    ->execute();
  if (isset($result['shopify_product']) && $result['shopify_product']) {
    return entity_load('shopify_product', array_keys($result['shopify_product']));
  }
  return array();
}

/**
 * Returns a variant that matches the passed option values.
 *
 * If no variant is found that matches all the options, null is returned.
 *
 * @param \ShopifyProduct $product
 *   Shopify product with variants.
 *
 * @param array $options
 *   Array of options to check against.
 */
function shopify_add_to_cart_get_variant_from_options(ShopifyProduct $product, array $options = array()) {
  $selected_variant = NULL;
  foreach ((array) $product->variants as $v) {
    foreach ((array) $v->option_values as $key => $value) {
      if ($value !== $options[$key]) {
        continue 2;
      }
    }
    $selected_variant = $v;
  }
  return $selected_variant;
}

function shopify_add_to_cart_ajax_callback($form, $form_state) {
  return $form;
}

// @todo obviously fix this
function shopify_product_access() {
  return TRUE;
}

function shopify_product_uri($entity) {
  return array(
    'path' => 'products/view/' . $entity->id,
  );
}

/**
 * Fetch a product object.
 *
 * @param $id
 *   Integer specifying the product id.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 * @return ShopifyProduct
 *   A fully-loaded product or FALSE if it cannot be loaded.
 *
 * @see shopify_product_load_multiple()
 */
function shopify_product_load($id, $reset = FALSE) {
  $product = shopify_product_load_multiple(array($id), array(), $reset);
  return $product ? reset($product) : FALSE;
}

/**
 * Load multiple product entities based on certain conditions.
 *
 * @param $ids
 *   An array of entity IDs.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 * @return ShopifyProduct
 *   An array of product entity objects, indexed by id.
 */
function shopify_product_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('shopify_product', $ids, $conditions, $reset);
}

/**
 * Delete multiple product entities.
 *
 * @param $ids
 *   An array of product entity IDs.
 */
function shopify_product_delete_multiple(array $ids) {
  entity_get_controller('shopify_product')->delete($ids);
}

/**
 * Implements hook_entity_form().
 *
 * Creates the edit/update form for the entity
 */
function shopify_product_form($form, &$form_state, ShopifyProduct $product = NULL, $action = 'new') {
  global $user;

  $form['#id'] = 'shopify-product-create-form';
  $form_state['shopify_product'] = $product ?: new ShopifyProduct();

  $form_state['#action'] = $action;

  $form['title'] = array(
    '#title' => t('Product or Variant Title'),
    '#type' => 'textfield',
    '#default_value' => $product->title,
    '#required' => TRUE,
  );

  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save product'),
    '#weight' => 40,
  );

  field_attach_form('shopify_product', $product, $form, $form_state);

  return $form;
}

/**
 * Implementation of hook_entity_info_alter().
 *
 * Redirect any links to shopify_tag taxonomy terms to a View so the tags
 * actually do something.
 */
function shopify_entity_info_alter(&$entity_info) {
  $entity_info['taxonomy_term']['bundles']['shopify_tags']['uri callback'] = 'shopify_taxonomy_term_uri';
}

/**
 * Entity uri callback for shopify_tag taxonomy terms.
 */
function shopify_taxonomy_term_uri($term) {
  return array(
    'path' => 'products/tags/' . $term->tid,
  );
}

function shopify_api_get_products() {
  $client = shopify_api_client();
  return $client->call('GET', '/admin/products.json');
}

function shopify_api_get_product($product_id) {
  $client = shopify_api_client();
  return $client->call('GET', "/admin/products/{$product_id}.json");
}

function shopify_api_get_product_variants($product_id) {
  $client = shopify_api_client();
  return $client->call('GET', "/admin/products/{$product_id}/variants.json");
}

function shopify_api_get_variant($variant_id) {
  $client = shopify_api_client();
  return $client->call('GET', "/admin/variants/{$variant_id}.json");
}


function shopify_theme($existing, $type, $theme, $path) {
  return array(
    'entity_property__shopify_product__body_html' => array(
      'base hook' => 'entity_property',
    ),
    'entity_property__shopify_product__price' => array(
      'base hook' => 'entity_property',
    ),
  );
}

function theme_entity_property__shopify_product__body_html(&$variables) {
  // Get the raw HTML and run it through check_markup, rather than check_plain
  // which is used in entity_property_default_render_value_by_type
  $variables['content'] = check_markup($variables['elements']['#entity_wrapped']->{$variables['property_name']}->value(), 'full_html');
  $output = '';

  // Render the label, if it's not hidden.
  if (!$variables['label_hidden']) {
    $output .= '<div' . $variables['title_attributes'] . '>' . $variables['label'] . ':&nbsp;</div>';
  }

  // Render the content.
  $content_suffix = '';
  if (!$variables['label_hidden'] || $variables['content_attributes']) {
    $output .= '<div' . $variables['content_attributes'] . '>';
    $content_suffix = '</div>';
  }
  $output .= $variables['content'] . $content_suffix;

  // Render the top-level DIV.
  return '<div' . $variables['attributes'] . '>' . $output . '</div>';
}

function theme_entity_property__shopify_product__price(&$variables) {
  // @todo Make price symbol configurable
  if ($variables['content']) {
    $variables['content'] = '$' . $variables['content'];
  }
  $output = '';

  // Render the label, if it's not hidden.
  if (!$variables['label_hidden']) {
    $output .= '<div' . $variables['title_attributes'] . '>' . $variables['label'] . ':&nbsp;</div>';
  }

  // Render the content.
  $content_suffix = '';
  if (!$variables['label_hidden'] || $variables['content_attributes']) {
    $output .= '<div' . $variables['content_attributes'] . '>';
    $content_suffix = '</div>';
  }
  $output .= $variables['content'] . $content_suffix;

  // Render the top-level DIV.
  return '<div' . $variables['attributes'] . '>' . $output . '</div>';
}


function shopify_image_default_styles() {
  $styles = array();

  $styles['shopify_product_thumbnail'] = array(
    'label' => 'Shopify Product Thumbnail',
    'effects' => array(
      array(
        'name' => 'image_scale',
        'data' => array(
          'width' => 150,
          'height' => 0,
          'upscale' => 0,
        ),
        'weight' => 0,
      ),
    ),
  );

  return $styles;
}