<?php
/**
 * @file
 * Main module file containing hooks and functions.
 */

/**
 *  Implements hook_init().
 */
function shopify_init() {
  // Mostly used for quick testing of things right now.
//  $client = shopify_api_client();
//  $info = $client->call('GET', '/admin/collects.json');
}

/**
 * Implements hook_views_api().
 */
function shopify_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'shopify') . '/views'
  );
}

/**
 * Implements hook_views_default_views().
 *
 * Imports views from the /views directory.
 */
function shopify_views_default_views() {
  $path = __DIR__ . '/views/*.view.inc';
  $views = array();
  foreach (glob($path) as $views_filename) {
    $view = FALSE;
    require_once($views_filename);
    $views[$view->name] = $view; // $view exists in the included file.
    unset($view);
  }
  return $views;
}

/**
 * Implements hook_menu().
 */
function shopify_menu() {
  $items['products/view/%shopify_product'] = array(
    'page callback' => 'entity_ui_entity_page_view',
    'page arguments' => array(2),
    'load arguments' => array('shopify_product'),
    'access arguments' => array(TRUE),
  );
  $items['admin/shopify'] = array(
    'page callback' => 'shopify_admin_page',
    'title' => 'Shopify',
    'access arguments' => array('administer shopify'),
    'file' => 'shopify.admin.inc',
  );
  $items['admin/shopify/overview'] = array(
    'title' => 'Shopify Overview',
    'description' => 'Shopify Overview',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/shopify/sync'] = array(
    'title' => 'Sync',
    'description' => 'Sync Shopify store information to the website.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('shopify_admin_sync_form'),
    'access arguments' => array('administer shopify'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'shopify.admin.inc',
  );
  $items['admin/shopify/webhooks'] = array(
    'title' => 'Webhooks',
    'description' => 'Manage Shopify Webhooks',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('shopify_webhooks_admin'),
    'access arguments' => array('administer shopify webhooks'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'shopify.admin.inc',
  );

  $items['shopify/webhook/%'] = array(
    'page callback' => 'shopify_incoming_webhook',
    'page arguments' => array(2),
    'access callback' => array(TRUE),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

function shopify_menu_alter(&$items) {
  $items['admin/shopify/products/add']['access callback'] = FALSE;
}

function shopify_incoming_webhook($hook) {
  $json = file_get_contents('php://input');
  $payload = json_decode($json, TRUE);
  $function = 'shopify_webhook_' . $hook;
  foreach (module_implements($function) as $module) {
    module_invoke($module, $function, $payload);
  }
  return '';
}

function shopify_shopify_webhook_products_create($payload) {
  shopify_shopify_webhook_products_update($payload);
}

function shopify_shopify_webhook_products_update($product) {
  $product_entity = shopify_product_update($product['id'], 0, $product);
  $product_entity->save();
  foreach ($product['variants'] as $v) {
    $variant = shopify_product_update($product['id'], $v['id'], $v);
    $variant->save();
  }
}

function shopify_shopify_webhook_products_delete($product) {
  shopify_delete_by_product_id($product['id']);
}

function shopify_shopify_webook_carts_update($payload) {
  //watchdog('shopify', print_r($payload, TRUE));
}

/**
 * Delete all Shopify Products.
 */
function shopify_delete_all_products() {
  $existing = db_query('SELECT s.id FROM {shopify_products} s');
  $ids = $existing->fetchCol();
  shopify_product_delete_multiple($ids);
}

/**
 * Delete all Shopify collections.
 */
function shopify_delete_all_collections() {
  $vocab = taxonomy_vocabulary_machine_name_load('shopify_collections');
  $tids = db_select('taxonomy_term_data', 'ttd')
    ->fields('ttd', array('tid'))
    ->condition('vid', $vocab->vid)
    ->execute()->fetchAllAssoc('tid');
  if ($tids) {
    entity_delete_multiple('taxonomy_term', array_keys($tids));

    // Delete collection field values with these tid values.
    db_delete('field_data_shopify_product_collections')
      ->condition('shopify_product_collections_tid', array_keys($tids), 'IN')
      ->execute();
  }
}

/**
 * Delete Shopify Products and Variants by Shopify Product ID.
 */
function shopify_delete_by_product_id($product_id) {
  $products = db_query('SELECT s.id FROM {shopify_products} s WHERE product_id = :product_id', array(':product_id' => $product_id));
  $ids = $products->fetchCol();
  shopify_product_delete_multiple($ids);
}

/**
 * Update a Shopify Product with new values or create a new one.
 *
 * @param int $product_id
 *   Shopify Product ID.
 * @param int $variant_id
 *   Shopify Variant ID.
 * @param array $new_values
 *   New values to apply to the Shopify Product.
 *
 * @return \ShopifyProduct
 *   Returns the newly created or modified Shopify Product.
 */
function shopify_product_update($product_id, $variant_id = 0, array $new_values = array()) {
  $shopify_product = shopify_product_load_single($product_id, $variant_id);
  if (!$shopify_product) {
    // Create a new product with those values.
    $shopify_product = new ShopifyProduct($new_values);
  }
  else {
    $shopify_product->__construct($new_values);
  }
  return $shopify_product;
}

/**
 * Load a single Shopify Product given a product and variant ID.
 *
 * @param int $product_id
 *   Shopify Product ID.
 * @param int $variant_id
 *   Shopify Variant ID.
 *
 * @return ShopifyProduct
 *   Returns the loaded Shopify Product entity.
 */
function shopify_product_load_single($product_id, $variant_id = 0) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'shopify_product')
    ->propertyCondition('product_id', $product_id)
    ->propertyCondition('variant_id', $variant_id)
    ->addMetaData('account', user_load(1)); // Run the query as user 1.
  $result = $query->execute();
  if (isset($result['shopify_product'])) {
    $ids = array_keys($result['shopify_product']);
    $shopify_product = entity_load_single('shopify_product', reset($ids));
  }
  return isset($shopify_product) ? $shopify_product : NULL;
}

/**
 * Implements hook_entity_info().
 */
function shopify_entity_info() {
  $return = array(
    'shopify_product' => array(
      'label' => t('Shopify Product'),
      'label callback' => 'shopify_product_label',
      'uri callback' => 'shopify_product_uri',
      'entity class' => 'ShopifyProduct',
      'controller class' => 'ShopifyProductController',
      'base table' => 'shopify_products',
      'metatags' => TRUE,
      'entity keys' => array(
        'id' => 'id',
        'label' => 'title'
      ),
      'fieldable' => TRUE,
      'metadata controller class' => 'ShopifyProductMetadataController',
      'extra fields controller class' => 'EntityDefaultExtraFieldsController',
      'admin ui' => array(
        'path' => 'admin/shopify/products',
        'controller class' => 'ShopifyProductsUIController',
        'menu wildcard' => '%shopify_product',

      ),
      'bundles' => array(
        'shopify_product' => array(
          'label' => 'Shopify Product Fields',
          'metatags' => TRUE,
          'admin' => array(
            'path' => 'admin/shopify/products_structure',
          ),
        ),
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'custom settings' => FALSE,
        ),
      ),
      'load hook' => 'shopify_product_load',
      'module' => 'shopify',
      'access callback' => 'shopify_product_access',
    ),
  );

  if (module_exists('search')) {
    $return['shopify_product']['view modes'] += array(
      'search_index' => array(
        'label' => t('Search index'),
        'custom settings' => FALSE,
      ),
      'search_result' => array(
        'label' => t('Search result'),
        'custom settings' => FALSE,
      ),
    );
  }

  return $return;
}

/**
 * Page callback for the bundle admin.
 */
function shopify_products_fields_admin() {
  return t('Administer Shopify Product fields and display');
}

/**
 * Add to cart form for Shopify products.
 */
function shopify_add_to_cart_form($form, &$form_state, ShopifyProduct $product = NULL) {
  $form_id = 'shopify-add-to-cart-form-' . $product->handle;
  $form['#id'] = $form_id;
  $form['#action'] = 'https://' . variable_get('shopify_api_domain') . '/cart/add';

  if ($product) {
    $form['#product'] = $product;
  }
  elseif ($form['#product']) {
    $product = $form['#product'];
  }

  if ((!isset($form_state['values']) || empty($form_state['values']['options'])) && $product->variants) {
    // Set default variant to the first one we have.
    $default_variant = reset($product->variants);
  }
  elseif ($product->variants) {
    // Set variant based on options passed.
    $default_variant = shopify_add_to_cart_get_variant_from_options($product, $form_state['values']['options']);
  }
  else {
    $default_variant = $product;
  }

  $form['product'] = array();

  $form['product']['variant'] = array();

  // Products with only 1 default variant will have a title of 'Default Title'.
  // We do not need to show options for these products.
  if ($product->variants && (!$default_variant || $default_variant->title !== 'Default Title')) {
    $form['product']['variant']['options']['#tree'] = TRUE;
    // Create option select lists based on product options.
    foreach ($product->options as $key => $select_list) {
      $form['product']['variant']['options'][] = array(
        '#type' => 'select',
        '#title' => check_plain(t($select_list['name'])),
        '#options' => array(),
        '#default_value' => $default_variant ? $default_variant->option_values[$key] : NULL,
        '#ajax' => array(
          'wrapper' => $form_id,
          'method' => 'replace',
          'callback' => 'shopify_add_to_cart_ajax_callback',
        ),
      );
    }

    // Create option lists based on variant options that are available.
    foreach ((array) $product->variants as $v) {
      foreach ((array) $v->option_values as $key => $option_value) {
        $form['product']['variant']['options'][$key]['#options'][$option_value] = $option_value;
      }
    }
  }

  if ($default_variant) {
    $form['product']['variant']['price'] = array(
      '#markup' => shopify_money_format() . $default_variant->wrapper()->price->value(),
    );
    // Required POST fields for add to cart form.
    $form['id'] = array(
      '#type' => 'hidden',
      '#value' => $default_variant->variant_id,
    );
    $form['return_to'] = array(
      '#type' => 'hidden',
      '#value' => 'back',
    );
    $form['product']['variant']['actions'] = array(
      '#type' => 'actions',
      'submit' => array(
        '#type' => 'submit',
        '#value' => t('Add to Cart'),
      ),
    );
  }
  else {
    $form['product']['variant']['actions'] = array(
      '#type' => 'actions',
      'submit' => array(
        '#markup' => t('Unavailable'),
      ),
    );
  }

  return $form;
}

/**
 * Get the money format that has been set in Shopify.
 *
 * @return string
 *   Shopify money format.
 */
function shopify_money_format() {
  $format = shopify_store_info()->money_format;
  return str_replace(' {{amount}}', '', $format);
}

/**
 * Get Shopify store information.
 *
 * @link https://docs.shopify.com/api/shop Shop API Documentation @endlink
 *
 * @return object
 *   Object of store information.
 */
function shopify_store_info() {
  return (object) variable_get('shopify_store_info', array());
}

/**
 * Load a product by it's given variant_id.
 *
 * @param int $variant_id
 *   Product variant ID.
 * @return ShopifyProduct[]
 *   Returns an array of shopify products with the variant id.
 */
function shopify_product_load_by_variant_id($variant_id) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'shopify_product')
    ->propertyCondition('variant_id', $variant_id)
    ->execute();
  if (isset($result['shopify_product']) && $result['shopify_product']) {
    return entity_load('shopify_product', array_keys($result['shopify_product']));
  }
  return array();
}

/**
 * Returns a variant that matches the passed option values.
 *
 * If no variant is found that matches all the options, null is returned.
 *
 * @param \ShopifyProduct $product
 *   Shopify product with variants.
 *
 * @param array $options
 *   Array of options to check against.
 *
 * @return \ShopifyProduct
 *   Returns the variant that matches the passed options.
 */
function shopify_add_to_cart_get_variant_from_options(ShopifyProduct $product, array $options = array()) {
  $selected_variant = NULL;
  foreach ((array) $product->variants as $v) {
    foreach ((array) $v->option_values as $key => $value) {
      if ($value !== $options[$key]) {
        continue 2;
      }
    }
    $selected_variant = $v;
  }
  return $selected_variant;
}

/**
 * Add to cart form AJAX callback.
 *
 * @see shopify_add_to_cart_form()
 */
function shopify_add_to_cart_ajax_callback($form, $form_state) {
  return $form;
}

/**
 * Shopify product access callback.
 *
 * @todo: FIX THIS TO NOT BE COMPLETELY OPEN.
 *
 * @return bool
 *   Returns TRUE if the user has access to the product.
 */
function shopify_product_access() {
  return TRUE;
}

/**
 * Get the entity URI path.
 *
 * @param ShopifyProduct $entity
 *
 * @return array
 *   Returns the path URI.
 */
function shopify_product_uri(ShopifyProduct $entity) {
  return array(
    'path' => 'products/view/' . $entity->id,
  );
}

/**
 * Fetch a product object.
 *
 * @param int $id
 *   Integer specifying the product id.
 * @param boolean $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return ShopifyProduct
 *   A fully-loaded product or FALSE if it cannot be loaded.
 *
 * @see shopify_product_load_multiple()
 */
function shopify_product_load($id, $reset = FALSE) {
  $product = shopify_product_load_multiple(array($id), array(), $reset);
  return $product ? reset($product) : FALSE;
}

/**
 * Load multiple product entities based on certain conditions.
 *
 * @param array $ids
 *   An array of entity IDs.
 * @param array $conditions
 *   An array of conditions to match against the {entity} table.
 * @param boolean $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return ShopifyProduct
 *   An array of product entity objects, indexed by id.
 */
function shopify_product_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('shopify_product', $ids, $conditions, $reset);
}

/**
 * Delete multiple product entities.
 *
 * @param array $ids
 *   An array of product entity IDs.
 */
function shopify_product_delete_multiple(array $ids) {
  foreach ($ids as $id) {
    if (module_exists('search')) {
      search_reindex($id, 'shopify_product');
    }
  }
  entity_get_controller('shopify_product')->delete($ids);
}

/**
 * Implements hook_field_extra_fields().
 *
 * Adds the add to cart form to the display field settings for organization.
 *
 * @see shopify_add_to_cart_form()
 */
function shopify_field_extra_fields() {
  $info = array();
  if (!isset($info['shopify_product']['shopify_product']['display']['full'])) {
    $info['shopify_product']['shopify_product']['display']['add_to_cart'] = array(
      'label' => t('Add to cart form'),
      'description' => t('Shopify Add to Cart form'),
      'weight' => 10,
    );
  }
  return $info;
}

/**
 * Implements hook_entity_form().
 *
 * Creates the edit/update form for the entity.
 */
function shopify_product_form($form, &$form_state, ShopifyProduct $product = NULL, $action = 'new') {
  $form['#id'] = 'shopify-product-create-form';
  $form_state['shopify_product'] = $product ?: new ShopifyProduct();

  $form_state['#action'] = $action;

  $form['title'] = array(
    '#title' => t('Product or Variant Title'),
    '#type' => 'textfield',
    '#default_value' => $product->title,
    '#required' => TRUE,
  );

  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save product'),
    '#weight' => 40,
  );

  field_attach_form('shopify_product', $product, $form, $form_state);
  // No idea why this is nessasary...
  $form['#submit'][] = 'shopify_product_form_submit';
  return $form;
}

/**
 * Form API submit callback for the entity type form.
 */
function shopify_product_form_submit(&$form, &$form_state) {
  $product = entity_ui_form_submit_build_entity($form, $form_state);
  $product->save();
  $form_state['redirect'] = 'admin/shopify/products';
}

/**
 * Implements hook_entity_info_alter().
 *
 * Redirect any links to shopify_tag taxonomy terms to a View so the tags
 * actually do something.
 */
function shopify_entity_info_alter(&$entity_info) {
  $entity_info['taxonomy_term']['bundles']['shopify_tags']['uri callback'] = 'shopify_taxonomy_term_uri';
}

/**
 * Entity uri callback for shopify_tag taxonomy terms.
 */
function shopify_taxonomy_term_uri($term) {
  return array(
    'path' => 'products/tags/' . $term->tid,
  );
}

/**
 * Gets the Shopify shop info from the API or the variable.
 *
 * @param bool $refresh
 *   Whether to refresh the info from the API.
 *
 * @return object
 *   Return object of store information.
 *
 * @throws \ShopifyApiException
 */
function shopify_api_get_shop_info($refresh = FALSE) {
  $info = (array) shopify_store_info();
  if ($refresh == TRUE || empty($info)) {
    $client = shopify_api_client();
    $info = $client->call('GET', '/admin/shop.json');
    variable_set('shopify_store_info', $info);
  }
  return (object) $info;
}

function shopify_api_get_shop_admin_path() {
  return 'https://' . shopify_api_get_shop_info()->domain . '/admin';
}

function shopify_api_get_product_path($product_id, $variant_id = 0) {
  $variant_path = '';
  if ($variant_id != 0) {
    $variant_path = '/variants/' . $variant_id;
  }
  return shopify_api_get_shop_admin_path() . '/products/' . $product_id . $variant_path;
}

/**
 * Get Shopify products from the API.
 *
 * @param array $options
 *   Arguments to pass to the API.
 *
 * @return array
 *   Returns the API response data.
 *
 * @throws \ShopifyApiException
 */
function shopify_api_get_products($options = array()) {
  $client = shopify_api_client();
  return $client->call('GET', '/admin/products.json', $options);
}

/**
 * Get Shopify collections from the API.
 *
 * @param array $options
 *   Arguments to pass to the API.
 * @param string $type
 *   Type of collections to get, options are:
 *   - both: Get smart and custom collections.
 *   - smart: Get smart collections only.
 *   - custom: Get custom collections only.
 *
 * @return array
 *   Returns the API response data.
 *
 * @throws \ShopifyApiException
 */
function shopify_api_get_collections($options = array(), $type = 'both') {
  $client = shopify_api_client();
  $smart_collections = $custom_collections = array();
  if ($type == 'both' || $type == 'smart') {
    $smart_collections = $client->call('GET', '/admin/smart_collections.json', $options);
  }
  if ($type == 'both' || $type == 'custom') {
    $custom_collections = $client->call('GET', '/admin/custom_collections.json', $options);
  }
  return array_merge($smart_collections, $custom_collections);
}

/**
 * Get Shopify collects from the API.
 *
 * @param array $options
 *   Arguments to pass the API.
 *
 * @return array
 *   Returns the API response data.
 *
 * @throws \ShopifyApiException
 */
function shopify_api_get_collects($options = array()) {
  $client = shopify_api_client();
  return $client->call('GET', '/admin/collects.json', $options);
}

/**
 * Get the Shopify product count from the API.
 *
 * @param array $options
 *   Arguments to pass to the API.
 *
 * @return array
 *   Returns the API response data.
 *
 * @throws \ShopifyApiException
 */
function shopify_api_get_product_count($options = array()) {
  $client = shopify_api_client();
  return $client->call('GET', '/admin/products/count.json', $options);
}

/**
 * Get Shopify collections count from the API.
 *
 * @param array $options
 *   Arguments to pass to the API.
 * @param string $type
 *   Type of collections to count, options are:
 *   - both: Get smart and custom collections count.
 *   - smart: Get smart collections count only.
 *   - custom: Get custom collections count only.
 *
 * @return array
 *   Returns the API response data.
 *
 * @throws \ShopifyApiException
 */
function shopify_api_get_collection_count($options = array(), $type = 'both') {
  $client = shopify_api_client();
  $smart_count = $custom_count = 0;
  if ($type == 'both' || $type == 'smart') {
    $smart_count = $client->call('GET', '/admin/smart_collections/count.json', $options);
  }
  if ($type == 'both' || $type == 'custom') {
    $custom_count = $client->call('GET', '/admin/custom_collections/count.json', $options);
  }
  return $custom_count + $smart_count;
}

/**
 * Get the Shopify product information.
 *
 * @param int $product_id
 *   Shopify Product ID.
 *
 * @return array
 *   Returns the API response data.
 *
 * @throws \ShopifyApiException
 */
function shopify_api_get_product($product_id) {
  $client = shopify_api_client();
  return $client->call('GET', "/admin/products/{$product_id}.json");
}

/**
 * Get the Shopify product variants.
 *
 * @param int $product_id
 *   Shopify Product ID.
 *
 * @return array
 *   Returns the API response data.
 *
 * @throws \ShopifyApiException
 */
function shopify_api_get_product_variants($product_id) {
  $client = shopify_api_client();
  return $client->call('GET', "/admin/products/{$product_id}/variants.json");
}

/**
 * Get the Shopify variant information.
 *
 * @param int $variant_id
 *   Shopify Variant ID.
 *
 * @return array
 *   Returns the API response data.
 *
 * @throws \ShopifyApiException
 */
function shopify_api_get_variant($variant_id) {
  $client = shopify_api_client();
  return $client->call('GET', "/admin/variants/{$variant_id}.json");
}

/**
 * Get the Shopify product images.
 *
 * @param int $product_id
 *   Shopify Product ID.
 *
 * @return array
 *   Returns the API response data.
 *
 * @throws \ShopifyApiException
 */
function shopify_api_get_product_images($product_id) {
  $client = shopify_api_client();
  return $client->call('GET', "/admin/products/{$product_id}/images.json");
}

function shopify_api_get_webhooks() {
  $client = shopify_api_client();
  return $client->call('GET', "/admin/webhooks.json");
}

function shopify_api_get_webhook_count($options = array()) {
  $client = shopify_api_client();
  return $client->call('GET', "/admin/webhooks/count.json");
}

function shopify_api_create_webhook($post) {
  $client = shopify_api_client();
  return $client->call('POST', "/admin/webhooks.json", $post);
}

function shopify_api_delete_webhook($id) {
  $client = shopify_api_client();
  return $client->call('DELETE', "/admin/webhooks/{$id}.json");
}

/**
 * Implements hook_theme().
 */
function shopify_theme($existing, $type, $theme, $path) {
  return array(
    'entity_property__shopify_product__body_html' => array(
      'base hook' => 'entity_property',
    ),
    'entity_property__shopify_product__price' => array(
      'base hook' => 'entity_property',
    ),
  );
}

/**
 * @param $variables
 * @return string
 */
function theme_entity_property__shopify_product__body_html(&$variables) {
  // Get the raw HTML and run it through check_markup, rather than check_plain
  // which is used in entity_property_default_render_value_by_type
  $variables['content'] = check_markup($variables['elements']['#entity_wrapped']->{$variables['property_name']}->value(), 'full_html');
  $output = '';

  // Render the label, if it's not hidden.
  if (!$variables['label_hidden']) {
    $output .= '<div' . $variables['title_attributes'] . '>' . $variables['label'] . ':&nbsp;</div>';
  }

  // Render the content.
  $content_suffix = '';
  if (!$variables['label_hidden'] || $variables['content_attributes']) {
    $output .= '<div' . $variables['content_attributes'] . '>';
    $content_suffix = '</div>';
  }
  $output .= $variables['content'] . $content_suffix;

  // Render the top-level DIV.
  return '<div' . $variables['attributes'] . '>' . $output . '</div>';
}

/**
 * @param $variables
 * @return string
 */
function theme_entity_property__shopify_product__price(&$variables) {
  if ($variables['content']) {
    $variables['content'] = shopify_money_format() . $variables['content'];
  }
  $output = '';

  // Render the label, if it's not hidden.
  if (!$variables['label_hidden']) {
    $output .= '<div' . $variables['title_attributes'] . '>' . $variables['label'] . ':&nbsp;</div>';
  }

  // Render the content.
  $content_suffix = '';
  if (!$variables['label_hidden'] || $variables['content_attributes']) {
    $output .= '<div' . $variables['content_attributes'] . '>';
    $content_suffix = '</div>';
  }
  $output .= $variables['content'] . $content_suffix;

  // Render the top-level DIV.
  return '<div' . $variables['attributes'] . '>' . $output . '</div>';
}

/**
 * Implements hook_image_default_styles().
 */
function shopify_image_default_styles() {
  $styles = array();

  $styles['shopify_product_thumbnail'] = array(
    'label' => 'Shopify Product Thumbnail',
    'effects' => array(
      array(
        'name' => 'image_scale',
        'data' => array(
          'width' => 150,
          'height' => 0,
          'upscale' => 0,
        ),
        'weight' => 0,
      ),
    ),
  );

  return $styles;
}

function shopify_products_reset_sync_datestamp() {
  $datetime = new DateTime('1/1/1970');
  $last_updated = $datetime->format('Y-m-d H:i');
  variable_set('shopify_last_product_sync', $last_updated);
}

function shopify_collections_reset_sync_datestamp() {
  $datetime = new DateTime('1/1/1970');
  $last_updated = $datetime->format('Y-m-d H:i');
  variable_set('shopify_last_collection_sync', $last_updated);
}

function shopify_form_shopify_product_form_alter(&$form, &$form_state, $hook) {
  $product = menu_get_object('shopify_product', 4);
  $edit_url = shopify_api_get_product_path($product->product_id, $product->variant_id);

  $form['help'] = array(
    '#markup' => t('Product data synced with Shopify is not editable. Edit those fields on Shopify instead. <a href="!edit_url" target="_blank">!edit_url</a>', array('!edit_url' => $edit_url)),
    '#weight' => -99,
  );

  $disable = array(
    'shopify_product_images',
    'shopify_product_tags',
    'shopify_product_collections',
    'title',
  );

  foreach ($disable as $key) {
    $form[$key]['#disabled'] = TRUE;
  }
}

/**
 * Implements hook_ctools_plugin_api().
 */
function shopify_ctools_plugin_api($owner, $api) {
  if ($owner == 'metatag' && $api == 'metatag') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_search_info().
 */
function shopify_search_info() {
  return array(
    'title' => 'Products',
  );
}

/**
 * Implements hook_search_access().
 */
function shopify_search_access() {
  return user_access('access shopify products');
}

/**
 * Implements hook_search_reset().
 */
function shopify_search_reset() {
  db_update('search_dataset')
    ->fields(array('reindex' => REQUEST_TIME))
    ->condition('type', 'shopify_product')
    ->execute();
}

/**
 * Implements hook_search_execute().
 */
function shopify_search_execute($keys = NULL, $conditions = NULL) {
  $keys = preg_replace('!\*+!', '%', $keys);
  $query = db_select('shopify_products')->extend('PagerDefault');
  $query->fields('shopify_products', array('id', 'variant_id'));
  $query->condition('variant_id', '0');
  $query->condition(db_or()->
    condition('title', '%' . db_like($keys) . '%', 'LIKE')->
    condition('body_html', '%' . db_like($keys) . '%', 'LIKE'));
  $product_ids = $query
    ->limit(15)
    ->execute()
    ->fetchCol();
  $products = shopify_product_load_multiple($product_ids);

  $results = array();
  foreach ($products as $product) {
    $build = entity_view('shopify_product', array($product), 'search_result');
    $rendered = drupal_render($build);
    $uri = entity_uri('shopify_product', $product);
    $results[] = array(
      'link' => url($uri['path'], array_merge($uri['options'], array('absolute' => TRUE))),
      'title' => $product->title,
      'snippet' => search_excerpt($keys, $rendered),
      'language' => entity_language('node', $product),
    );
  }

  return $results;
}

/**
 * Implements hook_search_status().
 */
function shopify_search_status() {
  $total = db_query('SELECT COUNT(*) FROM {shopify_products}')->fetchField();
  $remaining = db_query("SELECT COUNT(*) FROM shopify_products sp LEFT JOIN search_dataset d ON d.type = 'shopify_product' AND d.sid = sp.id WHERE d.sid IS NULL AND sp.variant_id = 0 OR d.reindex <> 0")->fetchField();
  return array('remaining' => $remaining, 'total' => $total);
}

/**
 * Implements hook_update_index().
 */
function shopify_update_index() {
  $limit = (int)variable_get('search_cron_limit', 100);

  $result = db_query_range("SELECT id FROM shopify_products sp LEFT JOIN search_dataset d ON d.type = 'shopify_product' AND d.sid = sp.id WHERE d.sid IS NULL AND sp.variant_id = 0 OR d.reindex <> 0  ORDER BY d.reindex ASC, sp.id ASC", 0, $limit, array(), array('target' => 'slave'));

  foreach ($result as $product) {
    _shopify_index_product($product);
  }

}

/**
 * Indexes a single product.
 *
 * @param $product
 *   The product to index.
 */
function _shopify_index_product($product) {
  $product = shopify_product_load($product->id);

  // Save the changed time of the most recent indexed product, for the search
  // results half-life calculation.
  variable_set('shopify_cron_last', $product->updated_at);

  // Render the node.
  $build = entity_view($product, 'search_index');
  unset($build['#theme']);
  $product->rendered = drupal_render($build);

  $text = '<h1>' . check_plain($product->title) . '</h1>' . $product->rendered;

  // Fetch extra data normally not visible
  $extra = module_invoke_all('shopify_product_update_index', $product);
  foreach ($extra as $t) {
    $text .= $t;
  }

  // Update index
  search_index($product->id, 'shopify_product', $text);
}